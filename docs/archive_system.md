# Система архивации заявок

## Обзор

Система архивации автоматически перемещает заявки на пропуски в архив на основе заданных правил. Архивные заявки не отображаются пользователям и не участвуют в поиске, но сохраняются в базе данных для административных целей.

## Правила архивации

### 1. Использованные заявки
- **Условие**: Статус `used` (использованный)
- **Время**: Через 24 часа после отметки об использовании (`used_at`)
- **Логика**: `used_at < now() - 24 hours`

### 2. Неиспользованные заявки
- **Условие**: Статус `active` (активный)
- **Время**: Через 7 дней после создания (`created_at`)
- **Логика**: `created_at < now() - 7 days`

## Архитектура

### Компоненты

1. **ArchiveService** - основной сервис архивации
2. **PassRepository** - репозиторий для работы с пропусками
3. **Database** - обновленная схема базы данных

### Поле архивации

В таблице `passes` добавлено поле:
```sql
is_archived BOOLEAN NOT NULL DEFAULT 0
```

## Функциональность

### Автоматическая архивация

- **Частота**: Каждые 6 часов
- **Процесс**: Фоновая задача `ArchiveService._archiving_loop()`
- **Логика**: Поиск и архивация заявок по правилам

### Исключение из поиска

Все методы поиска и получения заявок обновлены для исключения архивных:

- `get_user_passes()` - история заявок пользователя
- `search_passes_by_car_number()` - поиск охраны
- `get_recent_passes()` - последние заявки
- `get_active_user_passes()` - активные заявки пользователя

### Административные функции

- `get_archived_passes()` - получение архивных заявок
- `get_archive_statistics()` - статистика архива
- `restore_pass()` - восстановление из архива
- `permanently_delete_archived_passes()` - постоянное удаление

## Использование

### Инициализация

Сервис архивации автоматически инициализируется при запуске приложения:

```python
from easy_pass_bot.core.service_config import initialize_services

await initialize_services()
```

### Ручная архивация

```python
from easy_pass_bot.core.container import container

archive_service = await container.get(ArchiveService)
archived_count = await archive_service.archive_old_passes()
```

### Получение статистики

```python
stats = await archive_service.get_archive_statistics()
print(f"Всего заявок: {stats['total_passes']}")
print(f"В архиве: {stats['archived_count']}")
print(f"Активных: {stats['active_count']}")
```

## Миграция базы данных

### Выполнение миграции

```bash
cd /root/easy_pass_bot
python scripts/migrate_archive.py
```

### Откат миграции

```bash
python scripts/migrate_archive.py rollback
```

### Что делает миграция

1. Добавляет поле `is_archived` в таблицу `passes`
2. Создает индекс для оптимизации запросов
3. Устанавливает значение по умолчанию `0` для существующих записей

## Мониторинг

### Логи

Сервис архивации записывает в лог:
- Количество архивированных заявок
- Ошибки при архивации
- Статистику архива

### Метрики

Доступны через `get_archive_statistics()`:
- Общее количество заявок
- Количество архивных заявок
- Количество активных заявок
- Распределение по статусам
- Распределение по месяцам

## Тестирование

### Запуск тестов

```bash
cd /root/easy_pass_bot
python -m pytest tests/unit/test_archive_service.py -v
```

### Покрытие тестами

- Архивация старых заявок
- Получение архивных заявок
- Статистика архива
- Восстановление из архива
- Постоянное удаление
- Обработка ошибок

## Безопасность

### Доступ к архиву

- Архивные заявки недоступны через обычные API
- Доступ только через административные функции
- Логирование всех операций с архивом

### Целостность данных

- Архивация не удаляет данные
- Возможность восстановления
- Проверка прав доступа

## Производительность

### Индексы

Создан индекс для поля `is_archived`:
```sql
CREATE INDEX idx_passes_is_archived ON passes(is_archived);
```

### Оптимизация запросов

Все запросы обновлены для использования индексов и исключения архивных записей.

### Частота архивации

- Каждые 6 часов (настраивается)
- Пакетная обработка
- Обработка ошибок

## Устранение неполадок

### Проблемы с архивацией

1. Проверьте логи сервиса архивации
2. Убедитесь, что база данных обновлена
3. Проверьте права доступа к базе данных

### Проблемы с производительностью

1. Проверьте наличие индексов
2. Мониторьте размер архива
3. Рассмотрите периодическую очистку старых архивных записей

### Восстановление данных

1. Используйте `restore_pass()` для восстановления отдельных заявок
2. Проверьте логи для отслеживания операций
3. При необходимости выполните откат миграции



